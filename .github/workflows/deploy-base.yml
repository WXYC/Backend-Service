name: Build & Deploy Base Workflow

on:
  workflow_call:
    inputs:
      target:
        description: 'The application target to deploy (e.g., backend, auth).'
        required: false
        type: string
      version:
        description: 'The specific version to deploy (e.g., v1.2.3). Defaults to latest if not provided.'
        required: false
        type: string

jobs:
  validate_inputs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-tags: true

      - name: Validate Build Target
        if: inputs.target != ''
        run: |
          TARGET_INPUT="${{ inputs.target }}"

          if [ ! -d "apps/$TARGET_INPUT" ]; then
            echo "Error: The target directory 'apps/$TARGET_INPUT' does not exist." >&2
            exit 1
          fi
          echo "target input '$TARGET_INPUT' is valid."

      - name: Validate Version Input Format
        if: inputs.version != ''
        run: |
          VERSION_INPUT="${{ inputs.version }}"
          TARGET_INPUT="${{ inputs.target }}"

          if [[ ! "$VERSION_INPUT" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?(\+[a-zA-Z0-9.]+)?$ && "$VERSION_INPUT" != "latest" ]]; then
            echo "Error: The 'version' input must follow semantic versioning format (e.g., v1.0.0, v1.0.0-beta.1). Received: $VERSION_INPUT" >&2
            exit 1
          fi

          TAG_TO_CHECK="$TARGET_INPUT/$VERSION_INPUT"
          if [ "$VERSION_INPUT" != "latest" ]; then
            if ! git tag -l "$TAG_TO_CHECK" | grep -q "$TAG_TO_CHECK"; then
              echo "Error: The corresponding tag for target and version does not exist: $TAG_TO_CHECK"
              exit 1
            fi
          fi

          echo "Version input '$VERSION_INPUT' is valid."

  setup:
    needs: validate_inputs
    runs-on: ubuntu-latest
    outputs:
      targets: ${{ steps.detect_targets.outputs.TARGETS }}
      has_targets: ${{ steps.detect_targets.outputs.HAS_TARGETS }}
      build_id: ${{ steps.generate_build_id.outputs.id }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 2

      - name: Detect Build Target
        id: detect_targets
        run: |
          if [ -n "${{ inputs.target }}" ]; then
            echo "Using provided target: ${{ inputs.target }}"
            TARGETS="${{ inputs.target }}"
          else
            echo "Detecting targets from git diff..."
            TARGETS=$(git diff --name-only HEAD~1..HEAD | grep '^apps' | cut -d '/' -f 2 | sort -u)
          fi

          if [ -z "$TARGETS" ] ; then
            echo "No targets found. Exiting."
            echo "TARGETS=[]" >> $GITHUB_OUTPUT
            echo "HAS_TARGETS=false" >> $GITHUB_OUTPUT
          else
            echo "TARGETS=$TARGETS"
            echo "TARGETS=$(echo "$TARGETS" | jq -R -s -c 'split("\n") | map(select(length > 0))')" >> $GITHUB_OUTPUT
            echo "HAS_TARGETS=true" >> $GITHUB_OUTPUT
          fi

      - name: Generate Unique Build ID
        id: generate_build_id
        run: |
          ID=$(head -c 8 /dev/urandom | base64 | tr -dc A-Za-z0-9 | head -c 7)
          echo "Build ID: $ID"
          echo "id=$ID" >> $GITHUB_OUTPUT

  handle-git-tags:
    needs: setup
    runs-on: ubuntu-latest
    if: needs.setup.outputs.has_targets == 'true'
    strategy:
      matrix:
        target: ${{ fromJSON(needs.setup.outputs.targets) }}

    outputs:
      deploy_version: ${{ steps.determine_deploy_version.outputs.deploy_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-tags: true

      - name: Get Latest Tag
        id: latest_tag
        uses: ./.github/actions/latest_tag
        with:
          target: ${{ matrix.target }}

      - name: Bump Tag Version
        id: bump_version
        if: inputs.version == ''
        uses: ./.github/actions/semver
        with:
          version: ${{ steps.latest_tag.outputs.latest_tag }}
          bump: patch

      - name: Determine Deploy Version
        id: determine_deploy_version
        run: |
          if [ "${{ inputs.version }}" == "latest" ]; then
            LATEST_VERSION=$(echo ${{ steps.latest_tag.outputs.latest_tag }} | sed 's/[^0-9.]//g')
            echo "deploy_version=v$LATEST_VERSION"
            echo "deploy_version=v$LATEST_VERSION" >> $GITHUB_OUTPUT
          elif [ -n "${{ inputs.version }}" ]; then
            echo "deploy_version=${{ inputs.version }}" 
            echo "deploy_version=${{ inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ steps.latest_tag.outputs.is_initial }}" == "true" ]; then
            LATEST_VERSION=$(echo ${{ steps.latest_tag.outputs.latest_tag }} | sed 's/[^0-9.]//g')
            echo "deploy_version=v$LATEST_VERSION"
            echo "deploy_version=v$LATEST_VERSION" >> $GITHUB_OUTPUT
          else # Default case for merging changes for existing target with version bump
            echo "deploy_version=v${{ steps.bump_version.outputs.next_version }}"
            echo "deploy_version=v${{ steps.bump_version.outputs.next_version }}" >> $GITHUB_OUTPUT
          fi

      # Only apply new tag if no specific version was provided or latest is provided and there were no existing tags
      - name: Apply Tag to Ref
        if: inputs.version == '' || steps.latest_tag.outputs.is_initial == 'true'
        uses: actions/github-script@v8
        with:
          script: |
            github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'refs/tags/${{ matrix.target }}/${{ steps.determine_deploy_version.outputs.deploy_version }}',
              sha: context.sha
            })

      - name: Persist Tag
        run: |
          echo "${{ steps.determine_deploy_version.outputs.deploy_version }}" > deploy_version.txt

      - name: Upload Deploy Tag Artifact
        uses: actions/upload-artifact@v4
        with:
          name: version-${{ matrix.target }}-${{ needs.setup.outputs.build_id }}
          path: deploy_version.txt

  build:
    needs: [handle-git-tags, setup]
    runs-on: ubuntu-latest
    if: needs.setup.outputs.has_targets == 'true'
    strategy:
      matrix:
        target: ${{ fromJSON(needs.setup.outputs.targets) }}

    steps:
      # Checkout specific version if provided, otherwise current SHA
      - name: Determine Checkout Ref
        id: determine_checkout_ref
        run: |
          INPUT_VERSION="${{ inputs.version }}"
          TARGET_APP="${{ matrix.target }}"

          if [ "$INPUT_VERSION" == "latest" ] || [ -z "$INPUT_VERSION" ]; then
            echo "checkout_ref=${{ github.sha }}" >> $GITHUB_OUTPUT
          else
            echo "checkout_ref=refs/tags/$TARGET_APP/$INPUT_VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Download Target Tag
        id: download_deploy_tag
        uses: actions/download-artifact@v4
        with:
          name: version-${{ matrix.target }}-${{ needs.setup.outputs.build_id }}

      - name: Determine Target Version
        id: determine_version
        run: |
          DEPLOY_TAG=$(cat deploy_version.txt)
          if [[ -n DEPLOY_TAG ]]; then
            echo "deploy_version=$DEPLOY_TAG >> $GITHUB_OUTPUT"
          else
            echo "Couldn't find deploy version for target ${{ matrix.target }}"
            exit 1
          fi

      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ steps.determine_checkout_ref.outputs.checkout_ref }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Amazon ECR
        id: login-ecr
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin ${{ secrets.AWS_ECR_URI }}

      - name: Check if image exists in ECR
        id: check_image
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          TARGET_APP=${{ matrix.target }}
          DEPLOY_TAG=${{ steps.determine_version.outputs.deploy_version }}
          IMAGE_URI="${{ secrets.AWS_ECR_URI }}/$TARGET_APP:$DEPLOY_TAG"

          if aws ecr describe-images --repository-name $TARGET_APP --image-ids imageTag=$DEPLOY_TAG --region ${{ secrets.AWS_REGION }} > /dev/null 2>&1; then
            echo "Image $IMAGE_URI already exists in ECR. Skipping build."
            echo "image_exists=true" >> $GITHUB_OUTPUT
          else
            echo "Image $IMAGE_URI not found in ECR. Proceeding with build."
            echo "image_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Build Image
        if: steps.check_image.outputs.image_exists == 'false'
        run: |
          TARGET_APP=${{ matrix.target }}

          docker build --platform linux/amd64 -f Dockerfile.${TARGET_APP} -t ${TARGET_APP}:ci .

      - name: Tag and Push Image
        if: steps.check_image.outputs.image_exists == 'false'
        run: |
          TARGET_APP=${{ matrix.target }}
          TAG=${{ steps.determine_version.outputs.deploy_version }}

          IMAGE_URI="${{ secrets.AWS_ECR_URI }}/${TARGET_APP}"

          echo "Tagging Docker image..."
          docker tag ${TARGET_APP}:ci $IMAGE_URI:$TAG

          echo "Pushing Docker image to ECR..."
          docker push $IMAGE_URI:$TAG

          if [[ "${{ inputs.version }}" == "latest" || -z "${{ inputs.version }}" ]]; then
          echo "Tagging Docker image with 'latest'..."
          docker tag ${TARGET_APP}:ci $IMAGE_URI:latest
          echo "Pushing Docker image to ECR with 'latest' tag..."
          docker push $IMAGE_URI:latest
          fi

  deploy:
    needs: [setup, handle-git-tags, build]
    runs-on: ubuntu-latest
    if: needs.setup.outputs.has_targets == 'true'
    strategy:
      matrix:
        target: ${{ fromJSON(needs.setup.outputs.targets) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Download Target Tag
        id: download_deploy_tag
        uses: actions/download-artifact@v4
        with:
          name: version-${{ matrix.target }}-${{ needs.setup.outputs.build_id }}

      - name: Determine Target Version
        id: determine_version
        run: |
          DEPLOY_TAG=$(cat deploy_version.txt)
          if [[ -n DEPLOY_TAG ]]; then
            echo "deploy_version=$DEPLOY_TAG >> $GITHUB_OUTPUT"
          else
            echo "Couldn't find deploy version for target ${{ matrix.target }}"
            exit 1
          fi

      - name: Get Deploy Vars
        id: deploy_vars
        run: |
          TARGET_APP=${{ matrix.target }}
          PUBLISH_PORT=$(yq .publishPort apps/$TARGET_APP/package.json)

          echo "publish_port=$PUBLISH_PORT" >> $GITHUB_OUTPUT

      - name: Deploy Service
        uses: ./.github/actions/deploy-service
        with:
          target_app: ${{ matrix.target }}
          publish_port: ${{ steps.deploy_vars.outputs.publish_port }}
          deploy_tag: ${{ steps.determine_version.outputs.deploy_version }} # Use provided version or the newly bumped version
          ec2_host: ${{ secrets.EC2_HOST }}
          ec2_user: ${{ secrets.EC2_USER }}
          ec2_ssh_key: ${{ secrets.EC2_SSH_KEY }}
          aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws_region: ${{ secrets.AWS_REGION }}
          aws_ecr_uri: ${{ secrets.AWS_ECR_URI }}

      - name: Confirm server is up
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            PUBLISH_PORT=${{ steps.deploy_vars.outputs.publish_port }}
            echo "Waiting for server to start..."
            sleep 30  # Adjust sleep time as needed
            echo "Checking server status..."
            if curl -s --head  --request GET http://localhost:$PUBLISH_PORT/healthcheck | grep "200 OK" > /dev/null; then 
              echo "Server is up and running."
            else
              echo "Server is not running. Deployment failed." >&2
              exit 1
            fi
