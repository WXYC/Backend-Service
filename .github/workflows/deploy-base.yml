name: Build & Deploy Base Workflow

on:
  workflow_call:
    inputs:
      target:
        description: 'The application target to deploy (e.g., backend, auth).'
        required: false
        type: string
      version:
        description: 'The specific version to deploy (e.g., v1.2.3). Defaults to latest if not provided.'
        required: false
        type: string

jobs:
  validate_inputs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Validate Build Target
        if: inputs.target != ''
        run: |
          TARGET_INPUT="${{ inputs.target }}"

          if [ ! -d "apps/$TARGET_INPUT" ]; then
            echo "Error: The target directory 'apps/$TARGET_INPUT' does not exist." >&2
            exit 1
          fi
          echo "target input '$TARGET_INPUT' is valid."

      - name: Validate Version Input Format
        if: inputs.version != ''
        run: |
          VERSION_INPUT="${{ inputs.version }}"
          if [[ ! "$VERSION_INPUT" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?(\+[a-zA-Z0-9.]+)?$ && "$VERSION_INPUT" != "latest" ]]; then
            echo "Error: The 'version' input must follow semantic versioning format (e.g., v1.0.0, v1.0.0-beta.1). Received: $VERSION_INPUT" >&2
            exit 1
          fi
          echo "Version input '$VERSION_INPUT' is valid."

  detect-build-targets:
    needs: validate_inputs
    runs-on: ubuntu-latest
    outputs:
      targets: ${{ steps.detect_targets.outputs.TARGETS }}
      has_targets: ${{ steps.detect_targets.outputs.HAS_TARGETS }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 2

      - name: Detect Build Target
        id: detect_targets
        run: |
          if [ -n "${{ inputs.target }}" ]; then
            echo "Using provided target: ${{ inputs.target }}"
            TARGETS="${{ inputs.target }}"
          else
            echo "Detecting targets from git diff..."
            TARGETS=$(git diff --name-only HEAD~1..HEAD | grep '^apps' | cut -d '/' -f 2 | sort -u)
          fi

          if [ -z "$TARGETS" ] ; then
            echo "No targets found. Exiting."
            echo "TARGETS=[]" >> $GITHUB_OUTPUT
            echo "HAS_TARGETS=false" >> $GITHUB_OUTPUT
          else
            echo "TARGETS=$TARGETS"
            echo "TARGETS=$(echo "$TARGETS" | jq -R -s -c 'split("\n") | map(select(length > 0))')" >> $GITHUB_OUTPUT
            echo "HAS_TARGETS=true" >> $GITHUB_OUTPUT
          fi

  handle-git-tags:
    needs: detect-build-targets
    runs-on: ubuntu-latest
    if: needs.detect-build-targets.outputs.has_targets == 'true'
    strategy:
      matrix:
        target: ${{ fromJSON(needs.detect-build-targets.outputs.targets) }}

    outputs:
      deploy_version: ${{ steps.determine_deploy_version.outputs.deploy_version }}

    steps:
      - name: Get Latest Tag
        id: latest_tag
        uses: ./.github/actions/latest_tag.yml
        with:
          target: ${{ matrix.target }}

      - name: Bump Tag Version
        id: bump_version
        if: inputs.version == ''
        uses: ./.github/actions/semver.yml
        with:
          version: ${{ steps.latest_tag.outputs.latest_tag }}
          bump: patch

      - name: Determine Deploy Version
        id: determine_deploy_version
        run: |
          if [ -n "${{ inputs.version }}" ]; then
            VERSION_INPUT="${{ inputs.version }}"
            CLEAN_VERSION=$(echo "$VERSION_INPUT" | sed 's/[^0-9.]//g')
            echo "deploy_version=v$CLEAN_VERSION" >> $GITHUB_OUTPUT
          elif [ "${{ inputs.version }}" == "latest" ]; then
            echo "deploy_version=v${{ steps.latest_tag.outputs.latest_tag }}" >> $GITHUB_OUTPUT
          else
            echo "deploy_version=v${{ steps.bump_version.outputs.next_version }}" >> $GITHUB_OUTPUT
          fi

      - name: Apply Tag to Ref
        if: inputs.version == '' # Only apply new tag if no specific version was provided
        uses: actions/github-script@v5
        with:
          script: |
            github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'refs/tags/${{ matrix.target }}/${{ steps.determine_deploy_version.outputs.deploy_version }}',
              sha: context.sha
            })

  build:
    needs: [handle-git-tags, detect-build-targets]
    runs-on: ubuntu-latest
    if: needs.detect-build-targets.outputs.has_targets == 'true'
    strategy:
      matrix:
        target: ${{ fromJSON(needs.detect-build-targets.outputs.targets) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ inputs.version || github.sha }} # Checkout specific version if provided, otherwise current SHA

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Amazon ECR
        id: login-ecr
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin ${{ secrets.AWS_ECR_URI }}

      - name: Check if image exists in ECR
        id: check_image
        run: |
          TARGET_APP=${{ matrix.target }}
          DEPLOY_TAG=${{ needs.handle-git-tags.outputs.deploy_version }}
          IMAGE_URI="${{ secrets.AWS_ECR_URI }}/$TARGET_APP:$DEPLOY_TAG"

          if aws ecr describe-images --repository-name $TARGET_APP --image-ids imageTag=$DEPLOY_TAG --region ${{ secrets.AWS_REGION }} > /dev/null 2>&1; then
            echo "Image $IMAGE_URI already exists in ECR. Skipping build."
            echo "image_exists=true" >> $GITHUB_OUTPUT
          else
            echo "Image $IMAGE_URI not found in ECR. Proceeding with build."
            echo "image_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Build Image
        if: steps.check_image.outputs.image_exists == 'false'
        run: |
          TARGET_APP=${{ matrix.target }}

          docker build --platform linux/amd64 -f Dockerfile.${TARGET_APP} -t ${TARGET_APP}:ci .

      - name: Tag and Push Image
        if: steps.check_image.outputs.image_exists == 'false'
        run: |
          TARGET_APP=${{ matrix.target }}
          TAG=${{ needs.handle-git-tags.outputs.deploy_version }}

          IMAGE_URI="${{ secrets.AWS_ECR_URI }}/${TARGET_APP}"

          echo "Tagging Docker image..."
          docker tag ${TARGET_APP}:ci $IMAGE_URI:latest
          docker tag ${TARGET_APP}:ci $IMAGE_URI:$TAG

          echo "Pushing Docker image to ECR..."
          docker push $IMAGE_URI:latest
          docker push $IMAGE_URI:$TAG

  deploy:
    needs: [detect-build-targets, handle-git-tags, build]
    runs-on: ubuntu-latest
    if: needs.detect-build-targets.outputs.has_targets == 'true'
    strategy:
      matrix:
        target: ${{ fromJSON(needs.detect-build-targets.outputs.targets) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Get Deploy Vars
        id: deploy_vars
        run: |
          TARGET_APP=${{ matrix.target }}
          PUBLISH_PORT=$(yq .publishPort apps/$TARGET_APP/package.json)

          echo "publish_port=$PUBLISH_PORT" >> $GITHUB_OUTPUT

      - name: Deploy Service
        uses: ./.github/actions/deploy-service.yml
        with:
          target_app: ${{ matrix.target }}
          publish_port: ${{ steps.deploy_vars.outputs.publish_port }}
          deploy_tag: ${{ needs.handle-git-tags.outputs.deploy_version }} # Use provided version or the newly bumped version
          ec2_host: ${{ secrets.EC2_HOST }}
          ec2_user: ${{ secrets.EC2_USER }}
          ec2_ssh_key: ${{ secrets.EC2_SSH_KEY }}
          aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws_region: ${{ secrets.AWS_REGION }}
          aws_ecr_uri: ${{ secrets.AWS_ECR_URI }}

      - name: Confirm server is up
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            PUBLISH_PORT=${{ steps.deploy_vars.outputs.publish_port }}
            echo "Waiting for server to start..."
            sleep 30  # Adjust sleep time as needed
            echo "Checking server status..."
            if curl -s --head  --request GET http://localhost:$PUBLISH_PORT/healthcheck | grep "200 OK" > /dev/null; then 
              echo "Server is up and running."
            else
              echo "Server is not running. Deployment failed." >&2
              exit 1
            fi
