name: Migration Snapshot Test

# Tests migrations against a production-like schema snapshot
# Runs weekly and can be triggered manually

on:
  schedule:
    # Run every Sunday at 6 AM UTC
    - cron: '0 6 * * 0'
  workflow_dispatch:
    inputs:
      create_snapshot:
        description: 'Create new snapshot from production (requires prod DB access)'
        required: false
        default: false
        type: boolean
      snapshot_key:
        description: 'S3 key for snapshot (default: schema-snapshot-latest.sql)'
        required: false
        default: 'schema-snapshot-latest.sql'
        type: string

env:
  TEST_DB_NAME: wxyc_db_migration_test
  SNAPSHOT_S3_BUCKET: wxyc-ci-artifacts

jobs:
  test-migrations:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache node_modules
        id: cache-node-modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-modules-${{ runner.os }}-node20-${{ hashFiles('package-lock.json') }}

      - name: Install dependencies
        if: steps.cache-node-modules.outputs.cache-hit != 'true'
        run: npm ci

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Optional: Create new snapshot from production
      - name: Create production snapshot
        if: inputs.create_snapshot == true
        env:
          DB_HOST: ${{ secrets.PROD_DB_HOST }}
          DB_PORT: ${{ secrets.PROD_DB_PORT }}
          DB_NAME: ${{ secrets.PROD_DB_NAME }}
          DB_USERNAME: ${{ secrets.PROD_DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.PROD_DB_PASSWORD }}
        run: |
          node scripts/create-schema-snapshot.mjs \
            --output=/tmp/schema-snapshot.sql \
            --upload-s3

      # Download snapshot from S3
      - name: Download schema snapshot
        env:
          SNAPSHOT_KEY: ${{ inputs.snapshot_key || 'schema-snapshot-latest.sql' }}
        run: |
          aws s3 cp "s3://${SNAPSHOT_S3_BUCKET}/migration-snapshots/${SNAPSHOT_KEY}" /tmp/schema-snapshot.sql
          echo "Downloaded snapshot:"
          head -20 /tmp/schema-snapshot.sql

      # Run migration tests
      - name: Test migrations against snapshot
        id: test-migrations
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USERNAME: postgres
          DB_PASSWORD: postgres
        run: |
          node scripts/test-migrations-snapshot.mjs \
            --snapshot=/tmp/schema-snapshot.sql \
            --target-db=${{ env.TEST_DB_NAME }} \
            --output=json > /tmp/migration-results.json 2>&1 || true

          # Extract results for summary
          cat /tmp/migration-results.json

          # Check if successful
          SUCCESS=$(jq -r '.success' /tmp/migration-results.json)
          if [ "$SUCCESS" = "true" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
          fi

      # Upload results as artifact
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: migration-test-results
          path: /tmp/migration-results.json
          retention-days: 30

      # Lint migrations while we're at it
      - name: Lint migrations
        run: |
          node scripts/lint-migrations.js --json > /tmp/lint-results.json || true
          cat /tmp/lint-results.json

          # Count errors
          ERRORS=$(jq -r '.summary.errors' /tmp/lint-results.json)
          if [ "$ERRORS" != "0" ]; then
            echo "::warning::Migration linter found $ERRORS error(s)"
          fi

      # Estimate migration durations
      - name: Estimate migration durations
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USERNAME: postgres
          DB_PASSWORD: postgres
          DB_NAME: ${{ env.TEST_DB_NAME }}
        run: |
          node scripts/estimate-migration.mjs --all --output=json > /tmp/estimate-results.json || true
          cat /tmp/estimate-results.json

      # Create summary
      - name: Create job summary
        if: always()
        run: |
          echo "## Migration Snapshot Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Migration test results
          if [ -f /tmp/migration-results.json ]; then
            echo "### Migration Tests" >> $GITHUB_STEP_SUMMARY

            TOTAL=$(jq -r '.migrations | length' /tmp/migration-results.json)
            FAILED=$(jq -r '[.migrations[] | select(.status == "failed")] | length' /tmp/migration-results.json)

            if [ "$FAILED" = "0" ]; then
              echo "✅ All $TOTAL migrations passed" >> $GITHUB_STEP_SUMMARY
            else
              echo "❌ $FAILED of $TOTAL migrations failed" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Failed migrations:" >> $GITHUB_STEP_SUMMARY
              jq -r '.migrations[] | select(.status == "failed") | "- \(.name): \(.error)"' /tmp/migration-results.json >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Lint results
          if [ -f /tmp/lint-results.json ]; then
            echo "### Lint Results" >> $GITHUB_STEP_SUMMARY
            ERRORS=$(jq -r '.summary.errors' /tmp/lint-results.json)
            WARNINGS=$(jq -r '.summary.warnings' /tmp/lint-results.json)
            echo "- Errors: $ERRORS" >> $GITHUB_STEP_SUMMARY
            echo "- Warnings: $WARNINGS" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Duration estimates
          if [ -f /tmp/estimate-results.json ]; then
            echo "### Duration Estimates" >> $GITHUB_STEP_SUMMARY
            TOTAL_SECONDS=$(jq -r '.summary.totalEstimatedSeconds' /tmp/estimate-results.json)
            echo "Total estimated migration time: ${TOTAL_SECONDS}s" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

      # Fail job if migrations failed
      - name: Check test status
        if: steps.test-migrations.outputs.status == 'failed'
        run: |
          echo "Migration tests failed. See results above."
          exit 1

  # Notify on failure (optional - requires Slack webhook)
  notify-failure:
    needs: test-migrations
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'schedule'
    steps:
      - name: Send failure notification
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -n "$SLACK_WEBHOOK" ]; then
            curl -X POST -H 'Content-type: application/json' \
              --data '{"text":"⚠️ Weekly migration snapshot test failed. Check GitHub Actions for details."}' \
              "$SLACK_WEBHOOK"
          else
            echo "No Slack webhook configured, skipping notification"
          fi
