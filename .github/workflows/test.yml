name: CI

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild all images (ignore cache)'
        required: false
        default: false
        type: boolean

env:
  TEST_HOST: http://localhost
  CI_DB_PORT: 5433
  CI_PORT: 8081
  PORT: 8081
  CI_BETTER_AUTH_URL: http://localhost:8083/auth
  BETTER_AUTH_URL: http://localhost:8083/auth
  DB_USERNAME: test-user
  DB_PASSWORD: test-pw
  DB_NAME: wxyc_db
  AUTH_BYPASS: true

jobs:
  # Detect what changed to conditionally run jobs
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.changes.outputs.backend }}
      auth: ${{ steps.changes.outputs.auth }}
      shared: ${{ steps.changes.outputs.shared }}
      tests: ${{ steps.changes.outputs.tests }}
      db-init: ${{ steps.changes.outputs.db-init }}
      docs-only: ${{ steps.changes.outputs.docs-only }}
      src: ${{ steps.changes.outputs.src }}
      run-integration: ${{ steps.should-run.outputs.run-integration }}
      merge_base_sha: ${{ steps.merge-base.outputs.sha }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Need full history for merge-base

      - name: Get merge-base SHA
        id: merge-base
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PRs, get the merge-base between the PR and main
            MERGE_BASE=$(git merge-base origin/${{ github.base_ref }} ${{ github.sha }})
            echo "sha=$MERGE_BASE" >> $GITHUB_OUTPUT
            echo "Merge-base SHA: $MERGE_BASE"
          else
            # For pushes to main, use the current SHA
            echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT
            echo "Current SHA: ${{ github.sha }}"
          fi

      - name: Detect file changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            backend:
              - 'apps/backend/**'
            auth:
              - 'apps/auth/**'
            shared:
              - 'shared/**'
            tests:
              - 'tests/**'
            db-init:
              - 'dev_env/Dockerfile.init'
              - 'dev_env/init-db.mjs'
              - 'dev_env/package.init.json'
              - 'dev_env/seed_db.sql'
              - 'shared/database/src/migrations/**'
              - 'shared/database/src/schema.ts'
            docs-only:
              - '**/*.md'
              - 'docs/**'
            src:
              - 'apps/**'
              - 'shared/**'
              - 'tests/**'
              - 'package.json'
              - 'package-lock.json'
              - 'tsconfig.base.json'

      - name: Determine if integration tests should run
        id: should-run
        run: |
          FORCE_REBUILD="${{ inputs.force_rebuild }}"
          if [[ "$FORCE_REBUILD" == "true" || \
                "${{ steps.changes.outputs.backend }}" == "true" || \
                "${{ steps.changes.outputs.auth }}" == "true" || \
                "${{ steps.changes.outputs.shared }}" == "true" || \
                "${{ steps.changes.outputs.tests }}" == "true" ]]; then
            echo "run-integration=true" >> $GITHUB_OUTPUT
          else
            echo "run-integration=false" >> $GITHUB_OUTPUT
          fi

  # Fast lint and type check - always runs on code changes
  lint-and-typecheck:
    needs: detect-changes
    if: needs.detect-changes.outputs.src == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set Up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache node_modules
        id: cache-node-modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-modules-${{ runner.os }}-node20-${{ hashFiles('package-lock.json') }}

      - name: Validate cached node_modules
        id: validate-cache
        if: steps.cache-node-modules.outputs.cache-hit == 'true'
        run: |
          if npm ls --depth=0 >/dev/null 2>&1; then
            echo "valid=true" >> $GITHUB_OUTPUT
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Cache corrupted, will reinstall"
            rm -rf node_modules
          fi

      - name: Install Dependencies
        if: steps.cache-node-modules.outputs.cache-hit != 'true' || steps.validate-cache.outputs.valid == 'false'
        run: npm ci

      - name: Type check
        run: npm run typecheck

      - name: Lint
        run: npm run lint

      - name: Check formatting
        run: npm run format:check

      - name: Build
        run: npm run build

  # Unit tests - runs affected tests only
  unit-tests:
    needs: detect-changes
    if: needs.detect-changes.outputs.src == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Need full history for --changedSince

      - name: Set Up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache node_modules
        id: cache-node-modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-modules-${{ runner.os }}-node20-${{ hashFiles('package-lock.json') }}

      - name: Validate cached node_modules
        id: validate-cache
        if: steps.cache-node-modules.outputs.cache-hit == 'true'
        run: |
          if npm ls --depth=0 >/dev/null 2>&1; then
            echo "valid=true" >> $GITHUB_OUTPUT
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Cache corrupted, will reinstall"
            rm -rf node_modules
          fi

      - name: Install Dependencies
        if: steps.cache-node-modules.outputs.cache-hit != 'true' || steps.validate-cache.outputs.valid == 'false'
        run: npm ci

      - name: Run affected unit tests
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PRs, run tests affected by changes since base branch
            npx jest --config jest.unit.config.ts --changedSince=origin/${{ github.base_ref }} --coverage --passWithNoTests
          else
            # For pushes to main, run all unit tests
            npm run test:unit:coverage
          fi

      - name: Upload Coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: unit-test-coverage
          path: coverage/
          retention-days: 7

  # Integration tests - only when backend/auth/shared changes
  # Note: Job always runs to report status, but steps are skipped when no relevant changes
  Integration-Tests:
    needs: detect-changes
    runs-on: ubuntu-latest
    env:
      RUN_TESTS: ${{ needs.detect-changes.outputs.run-integration }}
    steps:
      - name: Skip notification
        if: env.RUN_TESTS != 'true'
        run: echo "No relevant changes detected, skipping integration tests"

      - name: Checkout Code
        if: env.RUN_TESTS == 'true'
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        if: env.RUN_TESTS == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to Amazon ECR
        if: env.RUN_TESTS == 'true'
        id: login-ecr
        continue-on-error: true
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin ${{ secrets.AWS_ECR_URI }}

      # db-init image: pull SHA-tagged image from ECR or build
      - name: Pull db-init image from ECR
        if: env.RUN_TESTS == 'true' && inputs.force_rebuild != true && needs.detect-changes.outputs.db-init == 'false'
        id: pull-db-init
        continue-on-error: true
        env:
          MERGE_BASE_SHA: ${{ needs.detect-changes.outputs.merge_base_sha }}
        run: |
          # Try SHA-tagged image first (most accurate), then fall back to :latest
          SHA_TAG="sha-${MERGE_BASE_SHA}"
          if docker pull ${{ secrets.AWS_ECR_URI }}/db-init:${SHA_TAG} 2>/dev/null; then
            echo "âœ… Pulled db-init image with SHA tag: ${SHA_TAG}"
            docker tag ${{ secrets.AWS_ECR_URI }}/db-init:${SHA_TAG} wxyc-db-init-image
          elif docker pull ${{ secrets.AWS_ECR_URI }}/db-init:latest 2>/dev/null; then
            echo "âš ï¸ SHA-tagged image not found, using :latest (may be stale)"
            docker tag ${{ secrets.AWS_ECR_URI }}/db-init:latest wxyc-db-init-image
          else
            echo "âŒ No ECR image available, will build locally"
            exit 1
          fi

      - name: Build db-init image
        if: env.RUN_TESTS == 'true' && (inputs.force_rebuild == true || needs.detect-changes.outputs.db-init == 'true' || steps.pull-db-init.outcome == 'failure')
        uses: docker/build-push-action@v6
        with:
          context: .
          file: dev_env/Dockerfile.init
          load: true
          push: false
          tags: wxyc-db-init-image
          cache-from: type=gha,scope=db-init
          cache-to: type=gha,mode=max,scope=db-init

      # auth image: pull SHA-tagged image from ECR or build
      - name: Pull auth image from ECR
        if: env.RUN_TESTS == 'true' && inputs.force_rebuild != true && needs.detect-changes.outputs.auth == 'false' && needs.detect-changes.outputs.shared == 'false'
        id: pull-auth
        continue-on-error: true
        env:
          MERGE_BASE_SHA: ${{ needs.detect-changes.outputs.merge_base_sha }}
        run: |
          SHA_TAG="sha-${MERGE_BASE_SHA}"
          if docker pull ${{ secrets.AWS_ECR_URI }}/auth:${SHA_TAG} 2>/dev/null; then
            echo "âœ… Pulled auth image with SHA tag: ${SHA_TAG}"
            docker tag ${{ secrets.AWS_ECR_URI }}/auth:${SHA_TAG} wxyc_auth_service:ci
          elif docker pull ${{ secrets.AWS_ECR_URI }}/auth:latest 2>/dev/null; then
            echo "âš ï¸ SHA-tagged image not found, using :latest (may be stale)"
            docker tag ${{ secrets.AWS_ECR_URI }}/auth:latest wxyc_auth_service:ci
          else
            echo "âŒ No ECR image available, will build locally"
            exit 1
          fi

      - name: Build auth image
        if: env.RUN_TESTS == 'true' && (inputs.force_rebuild == true || needs.detect-changes.outputs.auth == 'true' || needs.detect-changes.outputs.shared == 'true' || steps.pull-auth.outcome == 'failure')
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile.auth
          load: true
          push: false
          tags: wxyc_auth_service:ci
          cache-from: type=gha,scope=auth
          cache-to: type=gha,mode=max,scope=auth

      # backend image: pull SHA-tagged image from ECR or build
      - name: Pull backend image from ECR
        if: env.RUN_TESTS == 'true' && inputs.force_rebuild != true && needs.detect-changes.outputs.backend == 'false' && needs.detect-changes.outputs.shared == 'false'
        id: pull-backend
        continue-on-error: true
        env:
          MERGE_BASE_SHA: ${{ needs.detect-changes.outputs.merge_base_sha }}
        run: |
          SHA_TAG="sha-${MERGE_BASE_SHA}"
          if docker pull ${{ secrets.AWS_ECR_URI }}/backend:${SHA_TAG} 2>/dev/null; then
            echo "âœ… Pulled backend image with SHA tag: ${SHA_TAG}"
            docker tag ${{ secrets.AWS_ECR_URI }}/backend:${SHA_TAG} wxyc_backend_service:ci
          elif docker pull ${{ secrets.AWS_ECR_URI }}/backend:latest 2>/dev/null; then
            echo "âš ï¸ SHA-tagged image not found, using :latest (may be stale)"
            docker tag ${{ secrets.AWS_ECR_URI }}/backend:latest wxyc_backend_service:ci
          else
            echo "âŒ No ECR image available, will build locally"
            exit 1
          fi

      - name: Build backend image
        if: env.RUN_TESTS == 'true' && (inputs.force_rebuild == true || needs.detect-changes.outputs.backend == 'true' || needs.detect-changes.outputs.shared == 'true' || steps.pull-backend.outcome == 'failure')
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile.backend
          load: true
          push: false
          tags: wxyc_backend_service:ci
          cache-from: type=gha,scope=backend
          cache-to: type=gha,mode=max,scope=backend

      - name: Set Up Node.js
        if: env.RUN_TESTS == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache node_modules
        if: env.RUN_TESTS == 'true'
        id: cache-node-modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-modules-${{ runner.os }}-node20-${{ hashFiles('package-lock.json') }}

      - name: Validate cached node_modules
        id: validate-cache
        if: env.RUN_TESTS == 'true' && steps.cache-node-modules.outputs.cache-hit == 'true'
        run: |
          if npm ls --depth=0 >/dev/null 2>&1; then
            echo "valid=true" >> $GITHUB_OUTPUT
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Cache corrupted, will reinstall"
            rm -rf node_modules
          fi

      - name: Install Dependencies
        if: env.RUN_TESTS == 'true' && (steps.cache-node-modules.outputs.cache-hit != 'true' || steps.validate-cache.outputs.valid == 'false')
        run: npm ci

      - name: Lint .env file
        if: env.RUN_TESTS == 'true'
        run: npm run lint:env

      - name: Set Up Test Environment
        if: env.RUN_TESTS == 'true'
        run: |
          touch .env
          npm run ci:env

      - name: Run Integration Tests
        if: env.RUN_TESTS == 'true'
        # Note: Tests must run sequentially (--runInBand) because they share
        # show state, DJ sessions, and flowsheet entries. Parallel execution
        # causes tests to interfere with each other's join/leave operations.
        run: npm run ci:test

      - name: Upload Coverage Report
        uses: actions/upload-artifact@v4
        if: env.RUN_TESTS == 'true' && always()
        with:
          name: integration-test-coverage
          path: coverage/
          retention-days: 14

      # On push to main, push built images to ECR with SHA tags for cache
      # Note: db-init is skipped as it doesn't have an ECR repository (CI-only image)
      - name: Push images to ECR cache
        if: env.RUN_TESTS == 'true' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && github.ref == 'refs/heads/main'
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          SHA_TAG="sha-${{ github.sha }}"
          ECR_URI="${{ secrets.AWS_ECR_URI }}"

          echo "Pushing images to ECR with SHA tag: ${SHA_TAG}"

          # Push auth if it was built
          if docker image inspect wxyc_auth_service:ci > /dev/null 2>&1; then
            echo "ðŸ“¦ Pushing auth..."
            docker tag wxyc_auth_service:ci ${ECR_URI}/auth:${SHA_TAG}
            docker tag wxyc_auth_service:ci ${ECR_URI}/auth:latest
            docker push ${ECR_URI}/auth:${SHA_TAG}
            docker push ${ECR_URI}/auth:latest
          fi

          # Push backend if it was built
          if docker image inspect wxyc_backend_service:ci > /dev/null 2>&1; then
            echo "ðŸ“¦ Pushing backend..."
            docker tag wxyc_backend_service:ci ${ECR_URI}/backend:${SHA_TAG}
            docker tag wxyc_backend_service:ci ${ECR_URI}/backend:latest
            docker push ${ECR_URI}/backend:${SHA_TAG}
            docker push ${ECR_URI}/backend:latest
          fi

          echo "âœ… ECR cache updated with SHA: ${SHA_TAG}"

      - name: Clean Up Test Environment
        if: env.RUN_TESTS == 'true' && always()
        run: npm run ci:clean
